// frontend/src/supabaseDataService.ts
import { supabase } from './supabaseClient';
import { PostgrestError } from '@supabase/supabase-js';
import { FileObject } from '@supabase/storage-js';
import { getCanonicalStatus } from './utils/statusUtils';

// --- Base Facility Interface (Core Data) ---
export interface Facility {
  ID: string;
  Company: string | null;
  "Facility Name/Site": string | null;
  Location: string | null;
  "Operational Status": string | null;
  "Primary Recycling Technology": string | null;
  technology_category: string | null;
  // Keep numeric capacity here if needed for list/map views
  capacity_tonnes_per_year: number | null;
  Latitude: number | null;
  Longitude: number | null;
  created_at?: string;
  // Add any other core fields needed for list/map views
}

// --- NEW: Facility Details Interface (One-to-One) ---
export interface FacilityDetails {
  facility_id: string; // PK, FK to facilities.ID
  technology_description?: string | null;
  notes?: string | null; // Previously "Key Sources/Notes"
  website?: string | null;
  feedstock?: string | null;
  product?: string | null;
  investment_usd?: number | null;
  jobs?: number | null;
  ev_equivalent_per_year?: number | null;
  environmental_impact_details?: string | null;
  status_effective_date_text?: string | null; // Previously unmapped form field
}

// --- UPDATED: Facility Timeline Event Interface (One-to-Many) ---
export interface FacilityTimelineEvent {
  id?: string; // Optional: UUID generated by DB
  facility_id?: string; // FK to facilities.ID (set during insert)
  event_date: string | null; // Changed from date: string | number
  event_name: string | null; // Changed from event: string
  description?: string | null;
}

// --- NEW: Facility Document Interface (One-to-Many) ---
export interface FacilityDocument {
  id?: string; // Optional: UUID generated by DB
  facility_id?: string; // FK to facilities.ID (set during insert)
  title?: string | null;
  url?: string | null; // Stores storage path
}

// --- NEW: Facility Image Interface (One-to-Many) ---
export interface FacilityImage {
  id?: string; // Optional: UUID generated by DB
  facility_id?: string; // FK to facilities.ID (set during insert)
  image_url?: string | null; // Stores storage path
  alt_text?: string | null;
  order?: number | null;
}

// --- Combined Facility Data Interface (for getFacilityById) ---
// Represents the complete data structure fetched for the detail page
export interface FullFacilityData extends Facility {
  facility_details: FacilityDetails | null; // Use singular as it's one-to-one
  facility_timeline_events: FacilityTimelineEvent[];
  facility_documents: FacilityDocument[];
  facility_images: FacilityImage[];
}


// --- FacilityStats Interface (Keep as is for now) ---
export interface FacilityStats {
   totalFacilities: number;
   operatingFacilities: number;
   constructionFacilities: number;
   plannedFacilities: number;
}

// --- UPDATED FacilityFormData Interface (Nested Structure for Forms) ---
// Represents the data structure used in the frontend forms
export interface FacilityFormData {
  // Core Facility Fields (map directly to 'facilities' table)
  id?: string; // Corresponds to DB 'ID'
  company_name?: string | null; // Corresponds to DB 'Company'
  facility_name_site?: string | null; // Corresponds to DB 'Facility Name/Site'
  address?: string | null; // Corresponds to DB 'Location'
  status_name?: string | null; // Corresponds to DB 'Operational Status'
  technology_name?: string | null; // Corresponds to DB 'Primary Recycling Technology'
  technology_category?: string | null; // Corresponds to DB 'technology_category'
  processing_capacity_mt_year?: number | string | null; // Corresponds to DB 'capacity_tonnes_per_year' (handle parsing)
  latitude?: number | string | null; // Corresponds to DB 'Latitude' (handle parsing)
  longitude?: number | string | null; // Corresponds to DB 'Longitude' (handle parsing)

  // Nested Details (map to 'facility_details' table)
  details?: {
    technology_description?: string | null;
    notes?: string | null;
    website?: string | null;
    feedstock?: string | null;
    product?: string | null;
    investment_usd?: number | string | null; // Keep string for form input flexibility
    jobs?: number | string | null; // Keep string for form input flexibility
    ev_equivalent_per_year?: number | string | null; // Keep string for form input flexibility
    environmental_impact_details?: string | null;
    status_effective_date_text?: string | null;
  };

  // Related Lists (map to respective tables)
  timeline?: FacilityTimelineEvent[]; // Use updated interface
  documents?: FacilityDocument[]; // Use new interface
  images?: FacilityImage[]; // Use new interface (stores paths)

  // --- Deprecated/Removed Fields (previously nested/unmapped) ---
  // investment?: { total?: number | string | null }; // Replaced by details.investment_usd
  // environmentalImpact?: { details?: string }; // Replaced by details.environmental_impact_details
  // contactPerson?: string | null; // Removed section
  // contactEmail?: string | null; // Removed section
  // contactPhone?: string | null; // Removed section
}


// --- Storage Interfaces (Keep as is) ---
export interface StorageItem {
  name: string;
  path: string; // Full path from the bucket root
  type: 'file' | 'folder';
  url?: string | null; // Only files have URLs
  metadata?: FileObject['metadata']; // Only files have metadata in listFiles result
  created_at?: string;
  updated_at?: string;
  last_accessed_at?: string;
  id?: string | null; // Supabase FileObject ID (null for folders)
}
export interface StorageFile extends StorageItem {
  type: 'file';
  url: string | null;
}


  

 // --- Helper Functions (Keep as is) ---
 const handleSupabaseError = (error: PostgrestError | null, context: string): void => {
  if (error) {
    console.error(`Supabase error in ${context}:`, error.message, `(Code: ${error.code})`, error.details);
    throw new Error(`Supabase error in ${context}: ${error.message}`);
  }
};

const handleStorageError = (error: Error | null, context: string): void => {
    if (error) {
        console.error(`Supabase Storage error in ${context}:`, error.message);
        throw new Error(`Supabase Storage error in ${context}: ${error.message}`);
    }
};

const getPathFromSupabaseUrl = (url: string): string | null => {
    try {
        const urlObject = new URL(url);
        const pathSegments = urlObject.pathname.split('/');
        // Find the bucket name segment (e.g., 'public', 'facility-images')
        // This assumes bucket name is right after '/object/public/' or '/object/authenticated/'
        const objectSegmentIndex = pathSegments.findIndex(segment => segment === 'object');
        if (objectSegmentIndex !== -1 && pathSegments.length > objectSegmentIndex + 2) {
             // Path starts after the bucket name segment
            return pathSegments.slice(objectSegmentIndex + 2).join('/');
        }
        console.warn(`Could not extract path from Supabase Storage URL structure: ${url}`);
        return null;
    } catch (e) {
        console.error(`Invalid URL provided to getPathFromSupabaseUrl: ${url}`, e);
        return null;
    }
};


// --- REWRITTEN Supabase Service Functions (Database) ---

// Function to get all facilities (CORE DATA ONLY for list view)
export const getFacilities = async (): Promise<Facility[]> => {
    console.log("Attempting to fetch facilities core data from Supabase...");
    try {
        // Select only core fields needed for the list/map view
        const selectString = `
            ID,
            Company,
            "Facility Name/Site",
            Location,
            "Operational Status",
            "Primary Recycling Technology",
            technology_category,
            capacity_tonnes_per_year,
            Latitude,
            Longitude
        `;
        const { data, error } = await supabase
            .from('facilities')
            .select(selectString);

        handleSupabaseError(error, 'getFacilities');
        if (!data) {
            console.warn("Supabase returned null data for getFacilities query.");
            return [];
        }
        console.log(`Successfully fetched ${data.length} facilities (core) from Supabase.`);

        // Basic parsing might still be needed if DB stores numbers as text
        const parsedData = data.map(facility => {
             const parsedFacility: Partial<Facility> = { ...facility };
             // Example parsing (adjust if needed based on actual DB types)
             if (typeof parsedFacility.Latitude === 'string') parsedFacility.Latitude = parseFloat(parsedFacility.Latitude);
             if (typeof parsedFacility.Longitude === 'string') parsedFacility.Longitude = parseFloat(parsedFacility.Longitude);
             if (typeof parsedFacility.capacity_tonnes_per_year === 'string') parsedFacility.capacity_tonnes_per_year = parseFloat(parsedFacility.capacity_tonnes_per_year);

             // Handle potential NaN
             parsedFacility.Latitude = isNaN(parsedFacility.Latitude as number) ? null : parsedFacility.Latitude;
             parsedFacility.Longitude = isNaN(parsedFacility.Longitude as number) ? null : parsedFacility.Longitude;
             parsedFacility.capacity_tonnes_per_year = isNaN(parsedFacility.capacity_tonnes_per_year as number) ? null : parsedFacility.capacity_tonnes_per_year;

             return parsedFacility;
         });

        return parsedData as Facility[];
    } catch (error: unknown) {
        console.error("Caught error in getFacilities:", error instanceof Error ? error.message : error);
        throw error;
    }
};

// Function to get a single facility by ID with ALL related details
export const getFacilityById = async (facilityId: string): Promise<FullFacilityData | null> => {
  console.log(`Attempting to fetch facility with ID: ${facilityId} and related details...`);
  if (!facilityId) {
      console.error("getFacilityById error: facilityId is required.");
      return null;
  }
  try {
    // Use select with relationship syntax
    const selectString = `
        *,
        facility_details ( * ),
        facility_timeline_events ( * ),
        facility_documents ( * ),
        facility_images ( * )
    `;

    const { data, error } = await supabase
      .from('facilities')
      .select(selectString)
      .eq('ID', facilityId)
      .maybeSingle(); // Expecting one or null

    handleSupabaseError(error, `getFacilityById (ID: ${facilityId})`);
    if (!data) {
      console.log(`Facility with ID ${facilityId} not found.`);
      return null;
    }
    console.log(`Successfully fetched facility ${facilityId} with related data.`);

    // Supabase should return nested data based on relationships
    // Perform any necessary parsing or type adjustments here if needed
    // e.g., ensure numbers are numbers, dates are dates/strings as expected by frontend

    // Example: Ensure timeline dates are strings if needed by form
    const timeline = data.facility_timeline_events?.map((event: any) => ({ // Use any temporarily if type mismatch occurs
        ...event,
        event_date: event.event_date ? String(event.event_date) : null // Ensure string or null
    })) || [];

    // Example: Ensure details numbers are numbers (if stored as text/varchar)
    let details = data.facility_details;
    if (details) {
        details = {
            ...details,
            investment_usd: details.investment_usd ? Number(details.investment_usd) : null,
            jobs: details.jobs ? Number(details.jobs) : null,
            ev_equivalent_per_year: details.ev_equivalent_per_year ? Number(details.ev_equivalent_per_year) : null,
        };
        // Handle NaN
        if (isNaN(details.investment_usd as number)) details.investment_usd = null;
        if (isNaN(details.jobs as number)) details.jobs = null;
        if (isNaN(details.ev_equivalent_per_year as number)) details.ev_equivalent_per_year = null;
    }


    // Construct the FullFacilityData object
    const fullData: FullFacilityData = {
        // Spread core facility data
        ID: data.ID,
        Company: data.Company,
        "Facility Name/Site": data["Facility Name/Site"],
        Location: data.Location,
        "Operational Status": data["Operational Status"],
        "Primary Recycling Technology": data["Primary Recycling Technology"],
        technology_category: data.technology_category,
        capacity_tonnes_per_year: data.capacity_tonnes_per_year ? Number(data.capacity_tonnes_per_year) : null, // Ensure number
        Latitude: data.Latitude ? Number(data.Latitude) : null, // Ensure number
        Longitude: data.Longitude ? Number(data.Longitude) : null, // Ensure number
        created_at: data.created_at,
        // Add related data
        facility_details: details as FacilityDetails | null, // Cast after potential parsing
        facility_timeline_events: timeline as FacilityTimelineEvent[], // Cast after mapping
        facility_documents: data.facility_documents || [],
        facility_images: data.facility_images || [],
    };

     // Final NaN checks for core numeric fields
     if (isNaN(fullData.capacity_tonnes_per_year as number)) fullData.capacity_tonnes_per_year = null;
     if (isNaN(fullData.Latitude as number)) fullData.Latitude = null;
     if (isNaN(fullData.Longitude as number)) fullData.Longitude = null;


    return fullData;

  } catch (error: unknown) {
    console.error(`Caught error in getFacilityById (ID: ${facilityId}):`, error instanceof Error ? error.message : error);
    throw error;
  }
};

// Function to get facilities filtered by status_name (CORE DATA ONLY)
export const getFacilitiesByStatus = async (status: string): Promise<Facility[]> => {
  console.log(`Attempting to fetch facilities core data with status: ${status}...`);
  if (!status) {
      console.error("getFacilitiesByStatus error: status is required.");
      return [];
  }
  try {
    // Select only core fields needed for the list/map view
    const selectString = `
        ID,
        Company,
        "Facility Name/Site",
        Location,
        "Operational Status",
        "Primary Recycling Technology",
        technology_category,
        capacity_tonnes_per_year,
        Latitude,
        Longitude
    `;
    const { data, error } = await supabase
      .from('facilities')
      .select(selectString)
      .eq('"Operational Status"', status); // Use correct DB column name (quoted)

    handleSupabaseError(error, `getFacilitiesByStatus (Status: ${status})`);
    if (!data) {
      console.warn(`Supabase returned null data for getFacilitiesByStatus query (Status: ${status}).`);
      return [];
    }
    console.log(`Successfully fetched ${data.length} facilities (core) with status ${status}.`);

    // Add parsing similar to getFacilities if needed
    const parsedData = data.map(facility => {
         const parsedFacility: Partial<Facility> = { ...facility };
         if (typeof parsedFacility.Latitude === 'string') parsedFacility.Latitude = parseFloat(parsedFacility.Latitude);
         if (typeof parsedFacility.Longitude === 'string') parsedFacility.Longitude = parseFloat(parsedFacility.Longitude);
         if (typeof parsedFacility.capacity_tonnes_per_year === 'string') parsedFacility.capacity_tonnes_per_year = parseFloat(parsedFacility.capacity_tonnes_per_year);
         parsedFacility.Latitude = isNaN(parsedFacility.Latitude as number) ? null : parsedFacility.Latitude;
         parsedFacility.Longitude = isNaN(parsedFacility.Longitude as number) ? null : parsedFacility.Longitude;
         parsedFacility.capacity_tonnes_per_year = isNaN(parsedFacility.capacity_tonnes_per_year as number) ? null : parsedFacility.capacity_tonnes_per_year;
         return parsedFacility;
     });

    return parsedData as Facility[];
  } catch (error: unknown) {
    console.error(`Caught error in getFacilitiesByStatus (Status: ${status}):`, error instanceof Error ? error.message : error);
    throw error;
  }
};

// Function to add a new facility and its related details
export const addFacility = async (facilityInput: FacilityFormData): Promise<{ id: string } | null> => {
  console.log(`Attempting to add facility and details to Supabase...`);
  if (!facilityInput) {
      console.error("addFacility error: Invalid input data.");
      throw new Error("Invalid facility data provided for addFacility.");
  }

  // 1. Prepare core facility data
  const coreDataToInsert: Omit<Facility, 'created_at'> = { // Use Omit to exclude fields not inserted
      ID: facilityInput.id || crypto.randomUUID(), // Generate UUID if not provided
      Company: facilityInput.company_name ?? null,
      "Facility Name/Site": facilityInput.facility_name_site ?? null,
      Location: facilityInput.address ?? null,
      "Operational Status": facilityInput.status_name ?? null,
      "Primary Recycling Technology": facilityInput.technology_name ?? null,
      technology_category: facilityInput.technology_category ?? null,
      capacity_tonnes_per_year: facilityInput.processing_capacity_mt_year !== null && facilityInput.processing_capacity_mt_year !== undefined && !isNaN(Number(facilityInput.processing_capacity_mt_year))
          ? Number(facilityInput.processing_capacity_mt_year) : null,
      Latitude: facilityInput.latitude !== null && facilityInput.latitude !== undefined && !isNaN(Number(facilityInput.latitude))
          ? Number(facilityInput.latitude) : null,
      Longitude: facilityInput.longitude !== null && facilityInput.longitude !== undefined && !isNaN(Number(facilityInput.longitude))
          ? Number(facilityInput.longitude) : null,
  };

  try {
    // 2. Insert into 'facilities' table
    const { data: facilityData, error: facilityError } = await supabase
      .from('facilities')
      .insert(coreDataToInsert)
      .select('ID')
      .single();

    handleSupabaseError(facilityError, `addFacility - insert core`);
    if (!facilityData) {
        console.error(`Failed to add core facility data, Supabase returned null.`);
        return null;
    }
    const facilityId = facilityData.ID;
    console.log(`Successfully added core facility with ID: ${facilityId}.`);

    // 3. Prepare and insert into 'facility_details'
    if (facilityInput.details) {
        const detailsDataToInsert: Omit<FacilityDetails, 'facility_id'> & { facility_id: string } = {
            facility_id: facilityId, // Link to the facility
            technology_description: facilityInput.details.technology_description ?? null,
            notes: facilityInput.details.notes ?? null,
            website: facilityInput.details.website ?? null,
            feedstock: facilityInput.details.feedstock ?? null,
            product: facilityInput.details.product ?? null,
            investment_usd: facilityInput.details.investment_usd !== null && facilityInput.details.investment_usd !== undefined && !isNaN(Number(facilityInput.details.investment_usd))
                ? Number(facilityInput.details.investment_usd) : null,
            jobs: facilityInput.details.jobs !== null && facilityInput.details.jobs !== undefined && !isNaN(Number(facilityInput.details.jobs))
                ? Number(facilityInput.details.jobs) : null,
            ev_equivalent_per_year: facilityInput.details.ev_equivalent_per_year !== null && facilityInput.details.ev_equivalent_per_year !== undefined && !isNaN(Number(facilityInput.details.ev_equivalent_per_year))
                ? Number(facilityInput.details.ev_equivalent_per_year) : null,
            environmental_impact_details: facilityInput.details.environmental_impact_details ?? null,
            status_effective_date_text: facilityInput.details.status_effective_date_text ?? null,
        };
        const { error: detailsError } = await supabase
            .from('facility_details')
            .insert(detailsDataToInsert);
        handleSupabaseError(detailsError, `addFacility - insert details (ID: ${facilityId})`);
        console.log(`Successfully added details for facility ID: ${facilityId}.`);
    }

    // 4. Prepare and insert into 'facility_timeline_events'
    if (facilityInput.timeline && facilityInput.timeline.length > 0) {
        const timelineDataToInsert = facilityInput.timeline
            .filter(item => item.event_name) // Only insert items with an event name
            .map(item => ({
                facility_id: facilityId,
                event_date: item.event_date || null, // Handle null/undefined date
                event_name: item.event_name,
                description: item.description ?? null,
            }));

        if (timelineDataToInsert.length > 0) {
            const { error: timelineError } = await supabase
                .from('facility_timeline_events')
                .insert(timelineDataToInsert);
            handleSupabaseError(timelineError, `addFacility - insert timeline (ID: ${facilityId})`);
            console.log(`Successfully added ${timelineDataToInsert.length} timeline events for facility ID: ${facilityId}.`);
        }
    }

    // 5. Prepare and insert into 'facility_documents'
     if (facilityInput.documents && facilityInput.documents.length > 0) {
         const documentDataToInsert = facilityInput.documents
             .filter(doc => doc.title || doc.url) // Only insert if title or url exists
             .map(doc => ({
                 facility_id: facilityId,
                 title: doc.title ?? null,
                 url: doc.url ?? null, // Assuming url is the storage path
             }));

         if (documentDataToInsert.length > 0) {
             const { error: documentError } = await supabase
                 .from('facility_documents')
                 .insert(documentDataToInsert);
             handleSupabaseError(documentError, `addFacility - insert documents (ID: ${facilityId})`);
             console.log(`Successfully added ${documentDataToInsert.length} documents for facility ID: ${facilityId}.`);
         }
     }

     // 6. Prepare and insert into 'facility_images'
      if (facilityInput.images && facilityInput.images.length > 0) {
          const imageDataToInsert = facilityInput.images
              .filter(img => img.image_url) // Only insert if image_url exists
              .map((img, index) => ({
                  facility_id: facilityId,
                  image_url: img.image_url, // Assuming image_url is the storage path
                  alt_text: img.alt_text ?? null,
                  order: img.order ?? index, // Use index as default order
              }));

          if (imageDataToInsert.length > 0) {
              const { error: imageError } = await supabase
                  .from('facility_images')
                  .insert(imageDataToInsert);
              handleSupabaseError(imageError, `addFacility - insert images (ID: ${facilityId})`);
              console.log(`Successfully added ${imageDataToInsert.length} images for facility ID: ${facilityId}.`);
          }
      }

    return { id: facilityId }; // Return the ID of the newly created facility

  } catch (error: unknown) {
    console.error(`Caught error in addFacility:`, error instanceof Error ? error.message : error);
    // Consider cleanup logic here if partial inserts occurred, though complex without transactions
    throw error;
  }
};

// Function to update an existing facility and its related details
export const updateFacility = async (facilityId: string, updatedData: FacilityFormData): Promise<void> => {
  console.log(`Attempting to update facility ID: ${facilityId} and details in Supabase...`);
  if (!facilityId || !updatedData) {
      console.error("updateFacility error: facilityId and updatedData are required.");
      throw new Error("Invalid input for updateFacility.");
  }

  // --- 1. Update Core Facility Data ---
  const coreDataToUpdate: Partial<Omit<Facility, 'ID' | 'created_at'>> = {};
  if (updatedData.company_name !== undefined) coreDataToUpdate['Company'] = updatedData.company_name ?? null;
  if (updatedData.facility_name_site !== undefined) coreDataToUpdate['Facility Name/Site'] = updatedData.facility_name_site ?? null;
  if (updatedData.address !== undefined) coreDataToUpdate['Location'] = updatedData.address ?? null;
  if (updatedData.status_name !== undefined) coreDataToUpdate['Operational Status'] = updatedData.status_name ?? null;
  if (updatedData.technology_name !== undefined) coreDataToUpdate['Primary Recycling Technology'] = updatedData.technology_name ?? null;
  if (updatedData.technology_category !== undefined) coreDataToUpdate['technology_category'] = updatedData.technology_category ?? null;
  if (updatedData.processing_capacity_mt_year !== undefined) {
      coreDataToUpdate['capacity_tonnes_per_year'] = updatedData.processing_capacity_mt_year !== null && !isNaN(Number(updatedData.processing_capacity_mt_year))
          ? Number(updatedData.processing_capacity_mt_year) : null;
  }
  if (updatedData.latitude !== undefined) {
       coreDataToUpdate['Latitude'] = updatedData.latitude !== null && !isNaN(Number(updatedData.latitude))
           ? Number(updatedData.latitude) : null;
   }
   if (updatedData.longitude !== undefined) {
       coreDataToUpdate['Longitude'] = updatedData.longitude !== null && !isNaN(Number(updatedData.longitude))
           ? Number(updatedData.longitude) : null;
   }
   // Add other core fields if necessary

  try {
      if (Object.keys(coreDataToUpdate).length > 0) {
          console.log(`[updateFacility] Updating core data for ${facilityId}:`, JSON.stringify(coreDataToUpdate, null, 2));
          const { error: coreUpdateError } = await supabase
              .from('facilities')
              .update(coreDataToUpdate)
              .eq('ID', facilityId);
          handleSupabaseError(coreUpdateError, `updateFacility - core update (ID: ${facilityId})`);
          console.log(`Successfully updated core data for facility ${facilityId}.`);
      } else {
          console.log(`No core data changes detected for facility ${facilityId}.`);
      }

      // --- 2. Update/Insert Facility Details ---
      // Use upsert for facility_details as it has a 1:1 relationship based on facility_id
      if (updatedData.details) {
          const detailsData: FacilityDetails = {
              facility_id: facilityId, // Ensure FK is set
              technology_description: updatedData.details.technology_description ?? null,
              notes: updatedData.details.notes ?? null,
              website: updatedData.details.website ?? null,
              feedstock: updatedData.details.feedstock ?? null,
              product: updatedData.details.product ?? null,
              investment_usd: updatedData.details.investment_usd !== null && !isNaN(Number(updatedData.details.investment_usd))
                  ? Number(updatedData.details.investment_usd) : null,
              jobs: updatedData.details.jobs !== null && !isNaN(Number(updatedData.details.jobs))
                  ? Number(updatedData.details.jobs) : null,
              ev_equivalent_per_year: updatedData.details.ev_equivalent_per_year !== null && !isNaN(Number(updatedData.details.ev_equivalent_per_year))
                  ? Number(updatedData.details.ev_equivalent_per_year) : null,
              environmental_impact_details: updatedData.details.environmental_impact_details ?? null,
              status_effective_date_text: updatedData.details.status_effective_date_text ?? null,
          };
          console.log(`[updateFacility] Upserting details for ${facilityId}:`, JSON.stringify(detailsData, null, 2));
          const { error: detailsUpsertError } = await supabase
              .from('facility_details')
              .upsert(detailsData, { onConflict: 'facility_id' }); // Upsert based on the facility_id FK/PK
          handleSupabaseError(detailsUpsertError, `updateFacility - details upsert (ID: ${facilityId})`);
          console.log(`Successfully upserted details for facility ${facilityId}.`);
      }

      // --- 3. Update Related Lists (Delete and Re-insert Strategy) ---
      // This strategy is simpler but less efficient for large lists.
      // Consider a diff-based approach for optimization if needed later.

      // Timeline Events
      if (updatedData.timeline !== undefined) { // Check if timeline array exists in update data
          console.log(`[updateFacility] Updating timeline for ${facilityId}...`);
          // Delete existing timeline events
          const { error: deleteTimelineError } = await supabase
              .from('facility_timeline_events')
              .delete()
              .eq('facility_id', facilityId);
          handleSupabaseError(deleteTimelineError, `updateFacility - delete timeline (ID: ${facilityId})`);

          // Insert new timeline events
          if (updatedData.timeline.length > 0) {
              const timelineDataToInsert = updatedData.timeline
                  .filter(item => item.event_name) // Filter out items without event name
                  .map(item => ({
                      facility_id: facilityId,
                      event_date: item.event_date || null,
                      event_name: item.event_name,
                      description: item.description ?? null,
                  }));
              if (timelineDataToInsert.length > 0) {
                  const { error: insertTimelineError } = await supabase
                      .from('facility_timeline_events')
                      .insert(timelineDataToInsert);
                  handleSupabaseError(insertTimelineError, `updateFacility - insert timeline (ID: ${facilityId})`);
                  console.log(`Successfully inserted ${timelineDataToInsert.length} timeline events for ${facilityId}.`);
              }
          } else {
               console.log(`No new timeline events to insert for ${facilityId}.`);
          }
      }

       // Documents
       if (updatedData.documents !== undefined) {
           console.log(`[updateFacility] Updating documents for ${facilityId}...`);
           // Delete existing documents
           const { error: deleteDocumentsError } = await supabase
               .from('facility_documents')
               .delete()
               .eq('facility_id', facilityId);
           handleSupabaseError(deleteDocumentsError, `updateFacility - delete documents (ID: ${facilityId})`);

           // Insert new documents
           if (updatedData.documents.length > 0) {
               const documentDataToInsert = updatedData.documents
                   .filter(doc => doc.title || doc.url) // Filter out empty entries
                   .map(doc => ({
                       facility_id: facilityId,
                       title: doc.title ?? null,
                       url: doc.url ?? null, // Assumes url is storage path
                   }));
               if (documentDataToInsert.length > 0) {
                   const { error: insertDocumentsError } = await supabase
                       .from('facility_documents')
                       .insert(documentDataToInsert);
                   handleSupabaseError(insertDocumentsError, `updateFacility - insert documents (ID: ${facilityId})`);
                   console.log(`Successfully inserted ${documentDataToInsert.length} documents for ${facilityId}.`);
               }
           } else {
                console.log(`No new documents to insert for ${facilityId}.`);
           }
       }

       // Images
       if (updatedData.images !== undefined) {
            console.log(`[updateFacility] Updating images for ${facilityId}...`);
           // Delete existing images
           const { error: deleteImagesError } = await supabase
               .from('facility_images')
               .delete()
               .eq('facility_id', facilityId);
           handleSupabaseError(deleteImagesError, `updateFacility - delete images (ID: ${facilityId})`);

           // Insert new images
           if (updatedData.images.length > 0) {
               const imageDataToInsert = updatedData.images
                   .filter(img => img.image_url) // Filter out entries without a URL/path
                   .map((img, index) => ({
                       facility_id: facilityId,
                       image_url: img.image_url, // Assumes image_url is storage path
                       alt_text: img.alt_text ?? null,
                       order: img.order ?? index,
                   }));
               if (imageDataToInsert.length > 0) {
                   const { error: insertImagesError } = await supabase
                       .from('facility_images')
                       .insert(imageDataToInsert);
                   handleSupabaseError(insertImagesError, `updateFacility - insert images (ID: ${facilityId})`);
                   console.log(`Successfully inserted ${imageDataToInsert.length} images for ${facilityId}.`);
               }
           } else {
                console.log(`No new images to insert for ${facilityId}.`);
           }
       }

      console.log(`Successfully finished update process for facility ${facilityId}.`);

  } catch (error: unknown) {
    console.error(`Caught error in updateFacility (ID: ${facilityId}):`, error instanceof Error ? error.message : error);
    throw error; // Re-throw error to be caught by calling function
  }
};

// Function to delete a facility and potentially related data (if CASCADE is set up)
export const deleteFacility = async (facilityId: string): Promise<void> => {
  console.log(`Attempting to delete facility with ID: ${facilityId} from Supabase...`);
  if (!facilityId) {
      console.error("deleteFacility error: facilityId is required.");
      throw new Error("Invalid input for deleteFacility.");
  }
  try {
    // Deleting from 'facilities' should cascade delete related data if FKs are set up with ON DELETE CASCADE
    console.warn(`Deleting facility ${facilityId}. Ensure foreign keys have ON DELETE CASCADE set for related tables (details, timeline, documents, images) to be deleted automatically.`);
    // Also consider deleting related storage items (images, documents) separately if needed

    const { error } = await supabase
      .from('facilities')
      .delete()
      .eq('ID', facilityId);

    handleSupabaseError(error, `deleteFacility (ID: ${facilityId})`);
    console.log(`Successfully deleted facility ${facilityId} (and potentially related data via cascade).`);
  } catch (error: unknown) {
    console.error(`Caught error in deleteFacility (ID: ${facilityId}):`, error instanceof Error ? error.message : error);
    throw error;
  }
};

// Function to get facility statistics (likely unchanged, uses core data)
export const getFacilityStats = async (): Promise<FacilityStats> => {
  console.log("Attempting to calculate facility stats from Supabase (core data)...");
  try {
    // Select the columns needed for stats from the core 'facilities' table
    const { data: facilities, error } = await supabase
        .from('facilities')
        .select('ID, "Operational Status"'); // Use correct DB column names

    handleSupabaseError(error, 'getFacilityStats - fetch all');
    if (!facilities) {
        console.warn("Supabase returned null data for getFacilityStats query.");
        return { totalFacilities: 0, operatingFacilities: 0, constructionFacilities: 0, plannedFacilities: 0 };
    }

    const totalFacilities = facilities.length;
    let operatingFacilities = 0;
    let constructionFacilities = 0;
    let plannedFacilities = 0;

    facilities.forEach(facility => {
      // Use the correct DB column name "Operational Status"
      if (facility["Operational Status"]) {
        // Map the raw status name to canonical keys
        const canonicalStatus = getCanonicalStatus(facility["Operational Status"]);
        switch (canonicalStatus) {
          case 'operating': operatingFacilities++; break;
          case 'construction': constructionFacilities++; break;
          case 'planned': plannedFacilities++; break;
          // 'unknown' statuses are counted in total but not in specific categories
        }
      } else {
          // Log warning if status is missing, using ID if available
          console.warn(`Facility ${facility.ID || '(unknown ID)'} missing "Operational Status" for stats calculation.`); // Use uppercase ID
      }
    });

    console.log("Successfully calculated facility stats.");
    return { totalFacilities, operatingFacilities, constructionFacilities, plannedFacilities };
  } catch (error: unknown) {
    console.error("Caught error in getFacilityStats:", error instanceof Error ? error.message : error);
    return { totalFacilities: 0, operatingFacilities: 0, constructionFacilities: 0, plannedFacilities: 0 };
  }
 };


// --- NEW Function to get distinct operational statuses ---
// TODO: Review if this needs changes (likely not, uses core table)
export const getDistinctOperationalStatuses = async (): Promise<string[]> => {
    console.log("Attempting to fetch distinct operational statuses from Supabase...");
    try {
        // This likely still works as it queries the core 'facilities' table
        const { data, error } = await supabase
            .rpc('get_distinct_operational_statuses'); // Assuming this RPC exists and uses the correct column

        handleSupabaseError(error, 'getDistinctOperationalStatuses');

        if (!data || !Array.isArray(data)) {
            console.warn("Supabase returned null or non-array data for getDistinctOperationalStatuses RPC.");
            return [];
        }

        // Ensure the returned values are strings
        const statuses = data.map(item => String(item));
        console.log("Successfully fetched distinct operational statuses:", statuses);
        return statuses;

    } catch (error: unknown) {
        console.error("Caught error in getDistinctOperationalStatuses:", error instanceof Error ? error.message : error);
        return [];
    }
};


// --- Storage Functions (Keep as is, but ensure paths are handled correctly) ---

// Function to upload a file to Supabase Storage
export const uploadFile = async (bucket: string, path: string, file: File): Promise<{ path: string }> => {
    console.log(`Attempting to upload file to Supabase Storage: Bucket=${bucket}, Path=${path}`);
    try {
        const { data, error } = await supabase.storage
            .from(bucket)
            .upload(path, file, {
                cacheControl: '3600', // Example cache control
                upsert: true, // Overwrite if file exists
            });

        // Use the specific storage error handler
        handleStorageError(error, `uploadFile (Bucket: ${bucket}, Path: ${path})`);

        if (!data) {
            console.error(`Failed to upload file to ${bucket}/${path}, Supabase returned null data.`);
            throw new Error(`Upload failed, no data returned.`);
        }

        console.log(`Successfully uploaded file to ${bucket}/${data.path}`);
        // Return the path, which might be adjusted by Supabase (e.g., if folders were created)
        return { path: data.path };
    } catch (error: unknown) {
        console.error(`Caught error in uploadFile (Bucket: ${bucket}, Path: ${path}):`, error instanceof Error ? error.message : error);
        throw error; // Re-throw the error
    }
};


// Function to delete a file from Supabase Storage
export const deleteFile = async (bucket: string, path: string): Promise<void> => {
    console.log(`Attempting to delete file from Supabase Storage: Bucket=${bucket}, Path=${path}`);
    if (!path) {
        console.warn("deleteFile warning: No path provided, skipping deletion.");
        return;
    }
    try {
        const { data, error } = await supabase.storage
            .from(bucket)
            .remove([path]); // Pass path in an array

        handleStorageError(error, `deleteFile (Bucket: ${bucket}, Path: ${path})`);
        console.log(`Successfully requested deletion for file: ${bucket}/${path}`, data);
    } catch (error: unknown) {
        console.error(`Caught error in deleteFile (Bucket: ${bucket}, Path: ${path}):`, error instanceof Error ? error.message : error);
        throw error;
    }
};

// Function to create an empty folder (by uploading a placeholder file)
export const createFolder = async (bucket: string, folderPath: string): Promise<void> => {
    console.log(`Attempting to create folder in Supabase Storage: Bucket=${bucket}, Path=${folderPath}`);
    // Ensure folderPath ends with '/' and add a placeholder file name
    const placeholderPath = `${folderPath.endsWith('/') ? folderPath : folderPath + '/'}.placeholder`;
    try {
        // Upload an empty file to create the folder structure
        const { error } = await supabase.storage
            .from(bucket)
            .upload(placeholderPath, new Blob(['']), { contentType: 'text/plain', upsert: false });

        // Ignore 'Duplicate' error (code 409) if placeholder already exists, otherwise handle error
        if (error && error.message !== 'The resource already exists') {
             handleStorageError(error, `createFolder (Bucket: ${bucket}, Path: ${folderPath})`);
        } else if (error && error.message === 'The resource already exists') {
            console.log(`Folder placeholder already exists at ${placeholderPath}, folder structure likely exists.`);
        } else {
            console.log(`Successfully created folder structure via placeholder: ${bucket}/${folderPath}`);
        }
    } catch (error: unknown) {
        console.error(`Caught error in createFolder (Bucket: ${bucket}, Path: ${folderPath}):`, error instanceof Error ? error.message : error);
        throw error;
    }
};


// Function to get the public URL for a file
export const getFilePublicUrl = async (bucket: string, path: string): Promise<string | null> => {
    console.log(`Attempting to get public URL for: Bucket=${bucket}, Path=${path}`);
     if (!path) {
        console.warn("getFilePublicUrl warning: No path provided.");
        return null;
    }
    try {
        const { data } = supabase.storage
            .from(bucket)
            .getPublicUrl(path);

        if (!data || !data.publicUrl) {
            console.warn(`Could not get public URL for ${bucket}/${path}. Check if file exists and bucket permissions.`);
            return null;
        }
        console.log(`Successfully retrieved public URL for ${bucket}/${path}`);
        return data.publicUrl;
    } catch (error: unknown) { // Catch unknown type
         // Check if it's an expected error (e.g., file not found) or unexpected
         if (error instanceof Error && error.message.includes('Not found')) {
             console.warn(`File not found when getting public URL: ${bucket}/${path}`);
             return null; // Return null if file not found
         }
         // Log and re-throw unexpected errors
         console.error(`Caught unexpected error in getFilePublicUrl (Bucket: ${bucket}, Path: ${path}):`, error instanceof Error ? error.message : error);
         throw error;
     }
};


// Function to list files within a specific path (prefix) in a bucket
// TODO: Review if this needs changes (likely not, operates on storage directly)
export const listFiles = async (
    bucket: string,
    pathPrefix: string = '',
    options?: { limit?: number; offset?: number; sortBy?: { column: string; order: string } }
): Promise<FileObject[]> => {
    console.log(`Listing files in Supabase Storage: Bucket=${bucket}, PathPrefix=${pathPrefix}`);
    try {
        const { data, error } = await supabase.storage
            .from(bucket)
            .list(pathPrefix, {
                limit: options?.limit || 100, // Default limit
                offset: options?.offset || 0,
                sortBy: options?.sortBy || { column: 'name', order: 'asc' },
            });

        handleStorageError(error, `listFiles (Bucket: ${bucket}, PathPrefix: ${pathPrefix})`);

        if (!data) {
             console.warn(`No data returned when listing files for ${bucket}/${pathPrefix}`);
             return [];
         }

        console.log(`Successfully listed ${data.length} items in ${bucket}/${pathPrefix}`);
        return data;
    } catch (error: unknown) {
        console.error(`Caught error in listFiles (Bucket: ${bucket}, PathPrefix: ${pathPrefix}):`, error instanceof Error ? error.message : error);
        throw error;
    }
};


// --- Facility-Specific Storage Helpers ---

// Uploads an image specifically for a facility, using a structured path
export const uploadFacilityImage = async (facilityId: string, file: File): Promise<string> => {
    if (!facilityId) throw new Error("Facility ID is required to upload an image.");
    const fileExt = file.name.split('.').pop();
    const fileName = `${Date.now()}.${fileExt}`; // Unique file name
    // Define the path *within* the bucket
    const filePathInBucket = `${facilityId}/${fileName}`; 

    console.log(`Uploading facility image to bucket 'facility-images' at path: ${filePathInBucket}`);
    // Use the correct bucket name 'facility-images' and the path within it
    const { path: uploadedPath } = await uploadFile('facility-images', filePathInBucket, file); 
    // The returned path from Supabase might include the bucket name, 
    // but we typically want just the path relative to the bucket for storing in the DB.
    // However, uploadFile already returns data.path which should be correct.
    return uploadedPath; 
};

// Deletes a facility image using its storage path
export const deleteFacilityImage = async (imageUrl: string): Promise<void> => {
    const imagePath = getPathFromSupabaseUrl(imageUrl); // Extract path from URL
    if (imagePath) {
    await deleteFile('facility-images', imagePath); // Use 'facility-images' bucket
    } else {
        console.warn(`Could not delete image, invalid URL or path: ${imageUrl}`);
    }
};


// --- Advanced Storage Functions (Keep as is for now) ---

// Lists all items (files and folders) recursively, returning StorageItem objects
// TODO: Review if this needs changes (likely not)
export const listStorageItems = async (bucket: string, pathPrefix: string = ''): Promise<StorageItem[]> => {
    console.log(`Recursively listing all items in: Bucket=${bucket}, PathPrefix=${pathPrefix}`);
    const allItems: StorageItem[] = [];
    const foldersToProcess: string[] = [pathPrefix]; // Start with the initial path

    try {
        while (foldersToProcess.length > 0) {
            const currentPath = foldersToProcess.shift()!; // Non-null assertion as we check length
            console.log(`Processing path: ${currentPath}`);

            const { data: fileObjects, error } = await supabase.storage
                .from(bucket)
                .list(currentPath);

            handleStorageError(error, `listStorageItems - list path (Bucket: ${bucket}, Path: ${currentPath})`);

            if (fileObjects) {
                 // Use Promise.all to handle potential async operations inside map (like getting URLs)
                 const storageItemsPromises = fileObjects.map(async (fileObject): Promise<StorageItem | null> => {
                     const fullPath = `${currentPath ? currentPath + '/' : ''}${fileObject.name}`;
                     // Check if it's a folder (folders don't have 'id' in Supabase list results)
                     if (fileObject.id === null) {
                         // It's a folder
                         if (fullPath !== pathPrefix) { // Avoid re-adding the root prefix if it's empty
                             foldersToProcess.push(fullPath); // Add subfolder to process queue
                         }
                         return {
                             name: fileObject.name,
                             path: fullPath,
                             type: 'folder',
                             metadata: fileObject.metadata, // Folders might have metadata
                             // Timestamps might be null for folders depending on Supabase version/config
                             created_at: fileObject.created_at,
                             updated_at: fileObject.updated_at,
                             last_accessed_at: fileObject.last_accessed_at,
                             id: null,
                         };
                     } else {
                         // It's a file
                         // Optionally get public URL here if needed immediately, otherwise store path
                         // const publicUrl = await getFilePublicUrl(bucket, fullPath); // Uncomment if URL needed now
                         return {
                             name: fileObject.name,
                             path: fullPath, // Store the path
                             type: 'file',
                             url: null, // Set URL to null initially, generate on demand
                             metadata: fileObject.metadata,
                             created_at: fileObject.created_at,
                             updated_at: fileObject.updated_at,
                             last_accessed_at: fileObject.last_accessed_at,
                             id: fileObject.id,
                         };
                     }
                 });

                 const resolvedItems = await Promise.all(storageItemsPromises);
                 allItems.push(...resolvedItems.filter((item): item is StorageItem => item !== null)); // Add valid items
            }
        }
        console.log(`Finished listing items. Found ${allItems.length} total items.`);
        return allItems;
    } catch (error: unknown) {
        console.error(`Caught error in listStorageItems (Bucket: ${bucket}, PathPrefix: ${pathPrefix}):`, error instanceof Error ? error.message : error);
        throw error;
    }
};

// Gets only files, converting StorageItem to StorageFile (potentially adding public URL)
// TODO: Review if this needs changes (likely not)
export const getStorageFiles = async (bucket: string, pathPrefix?: string): Promise<StorageFile[]> => {
    const allItems = await listStorageItems(bucket, pathPrefix);
    const files = allItems.filter(item => item.type === 'file');

    // Optionally generate public URLs here if needed by the caller immediately
    // const filesWithUrls = await Promise.all(files.map(async file => {
    //     const url = await getFilePublicUrl(bucket, file.path);
    //     return { ...file, url: url, type: 'file' as const }; // Ensure type is 'file'
    // }));
    // return filesWithUrls;

    // Return files with path only, URL can be generated later
    return files.map(file => ({ ...file, url: null, type: 'file' as const }));
};


// Interface for Tree structure used by buildFolderTree
export interface TreeNode {
  name: string;
  path: string;
  type: 'file' | 'folder';
  children?: TreeNode[];
  // Include other StorageItem properties if needed
  metadata?: FileObject['metadata'];
  url?: string | null;
}

// Gets all items (files/folders) recursively - potentially more efficient if list supports recursion
// TODO: Review if this needs changes (likely not)
export const getAllStorageItems = async (bucket: string): Promise<StorageItem[]> => {
     console.log(`Getting all storage items for bucket: ${bucket}`);
     const allItems: StorageItem[] = [];
     const foldersToProcess: string[] = ['']; // Start at the root

     try {
         while (foldersToProcess.length > 0) {
             const currentPath = foldersToProcess.shift()!;
             const { data: fileObjects, error } = await supabase.storage
                 .from(bucket)
                 .list(currentPath, { limit: 1000 }); // Use a large limit

             handleStorageError(error, `getAllStorageItems - list path (Bucket: ${bucket}, Path: ${currentPath})`);

             if (fileObjects) {
                 const storageItemsPromises = fileObjects.map(async (fileObject): Promise<StorageItem | null> => {
                     const fullPath = `${currentPath ? currentPath + '/' : ''}${fileObject.name}`;
                     if (fileObject.id === null) { // It's a folder based on Supabase list behavior
                         foldersToProcess.push(fullPath);
                         return {
                             name: fileObject.name,
                             path: fullPath,
                             type: 'folder',
                             metadata: fileObject.metadata,
                             created_at: fileObject.created_at,
                             updated_at: fileObject.updated_at,
                             last_accessed_at: fileObject.last_accessed_at,
                             id: null,
                         };
                     } else { // It's a file
                         return {
                             name: fileObject.name,
                             path: fullPath,
                             type: 'file',
                             url: null, // Store path, generate URL on demand
                             metadata: fileObject.metadata,
                             created_at: fileObject.created_at,
                             updated_at: fileObject.updated_at,
                             last_accessed_at: fileObject.last_accessed_at,
                             id: fileObject.id,
                         };
                     }
                 });
                 const resolvedItems = await Promise.all(storageItemsPromises);
                 allItems.push(...resolvedItems.filter((item): item is StorageItem => item !== null));
             }
         }

         // Add root folders explicitly if they weren't captured (e.g., if root list call only returns files)
         // This part might need adjustment based on exact `list('')` behavior
         const { data: rootObjects, error: rootError } = await supabase.storage.from(bucket).list('', { limit: 1000 });
         handleStorageError(rootError, `getAllStorageItems - list root`);
         if (rootObjects) {
             rootObjects.forEach(obj => {
                 if (obj.id === null && !allItems.some(item => item.path === obj.name && item.type === 'folder')) {
                     allItems.push({
                         name: obj.name, path: obj.name, type: 'folder', id: null,
                         metadata: obj.metadata, created_at: obj.created_at, updated_at: obj.updated_at, last_accessed_at: obj.last_accessed_at
                     });
                 }
             });
         }


         // Deduplicate based on path (might happen if list returns overlapping results)
         const uniqueItems = Array.from(new Map(allItems.map(item => [item.path, item])).values());
         console.log(`Finished getting all items. Found ${uniqueItems.length} unique items.`);
         return uniqueItems;

     } catch (error: unknown) {
         console.error(`Caught error in getAllStorageItems (Bucket: ${bucket}):`, error instanceof Error ? error.message : error);
         throw error;
     }
 };


// Builds a hierarchical tree structure from a flat list of StorageItems
// TODO: Review if this needs changes (likely not)
export const buildFolderTree = (items: StorageItem[]): TreeNode[] => {
    const tree: TreeNode[] = [];
    const map: { [key: string]: TreeNode } = {};

    // Sort items to process folders before files within the same directory level
    items
        .sort((a, b) => {
            // Sort by path depth first, then type (folders first), then name
            const depthA = a.path.split('/').length;
            const depthB = b.path.split('/').length;
            if (depthA !== depthB) return depthA - depthB;
            if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
            return a.name.localeCompare(b.name);
        })
        .forEach(item => {
            const node: TreeNode = { ...item, children: item.type === 'folder' ? [] : undefined };
            map[item.path] = node;

            const parentPath = item.path.substring(0, item.path.lastIndexOf('/'));

            if (parentPath && map[parentPath] && map[parentPath].type === 'folder') {
                // Ensure children array exists before pushing
                 if (!map[parentPath].children) {
                     map[parentPath].children = []; // Initialize if it doesn't exist
                 }
                map[parentPath].children!.push(node); // Add to parent's children
            } else if (!parentPath) {
                // It's a root item
                tree.push(node);
            } else {
                 // Orphaned item (parent folder might not be in the list yet or path is inconsistent)
                 // Add it to the root for now, or handle differently if needed
                 console.warn(`Orphaned item found or parent not processed yet: ${item.path}, Parent: ${parentPath}`);
                 tree.push(node);
            }
        });

     // Sort children alphabetically within each folder node
     Object.values(map).forEach(node => {
         if (node.children) {
             node.children.sort((a, b) => {
                  if (a.type !== b.type) return a.type === 'folder' ? -1 : 1; // Folders first
                  return a.name.localeCompare(b.name); // Then by name
              });
         }
     });
     // Sort root nodes
      tree.sort((a, b) => {
          if (a.type !== b.type) return a.type === 'folder' ? -1 : 1;
          return a.name.localeCompare(b.name);
      });


    return tree;
};


// Moves a file within a bucket
// TODO: Review if this needs changes (likely not)
export const moveFile = async (bucket: string, sourcePath: string, destinationPath: string): Promise<void> => {
    console.log(`Attempting to move file in Supabase Storage: Bucket=${bucket}, From=${sourcePath}, To=${destinationPath}`);
    if (!sourcePath || !destinationPath) {
        throw new Error("Source and destination paths are required for moveFile.");
    }
    try {
        const { error } = await supabase.storage
            .from(bucket)
            .move(sourcePath, destinationPath);

        handleStorageError(error, `moveFile (Bucket: ${bucket}, From: ${sourcePath}, To: ${destinationPath})`);
        console.log(`Successfully moved file from ${sourcePath} to ${destinationPath}`);
    } catch (error: unknown) {
        console.error(`Caught error in moveFile (Bucket: ${bucket}, From: ${sourcePath}, To: ${destinationPath}):`, error instanceof Error ? error.message : error);
        throw error;
    }
};


// Renames a folder by moving all its contents recursively
// NOTE: This can be slow and potentially incomplete for very large folders due to listing limits.
// Consider server-side functions or direct DB manipulation for large-scale renames if needed.
// TODO: Review if this needs changes (likely not)
export const renameFolder = async (bucket: string, oldPathPrefix: string, newPathPrefix: string): Promise<void> => {
    console.log(`Attempting to rename folder in Supabase Storage: Bucket=${bucket}, From=${oldPathPrefix}, To=${newPathPrefix}`);
    if (!oldPathPrefix || !newPathPrefix) {
        throw new Error("Old and new path prefixes are required for renameFolder.");
    }
    // Ensure prefixes don't have leading/trailing slashes for consistency
    const oldPrefix = oldPathPrefix.replace(/^\/|\/$/g, '');
    const newPrefix = newPathPrefix.replace(/^\/|\/$/g, '');

    if (!oldPrefix) {
        throw new Error("Cannot rename the root directory.");
    }
    if (newPrefix.startsWith(oldPrefix + '/')) {
         throw new Error("Cannot move a folder into itself.");
     }

    try {
        // 1. List all items (files and folders) under the old prefix
        console.log(`Listing items under old prefix: ${oldPrefix}`);
        const allItems = await getAllStorageItems(bucket); // Get all items in the bucket
        const itemsToMove = allItems.filter(item => item.path.startsWith(oldPrefix + '/') || item.path === oldPrefix);

        if (itemsToMove.length === 0) {
            console.warn(`No items found under prefix ${oldPrefix} to rename.`);
            // Check if the folder might exist as an empty placeholder
             try {
                 const { error: movePlaceholderError } = await supabase.storage
                     .from(bucket)
                     .move(`${oldPrefix}/.placeholder`, `${newPrefix}/.placeholder`);
                 if (!movePlaceholderError) {
                     console.log(`Successfully moved placeholder for empty folder ${oldPrefix} to ${newPrefix}`);
                     return; // Exit if only placeholder moved
                 } else if (movePlaceholderError.message.includes('does not exist')) {
                     // Placeholder doesn't exist either, folder likely doesn't exist at all
                     console.warn(`Folder ${oldPrefix} or its placeholder not found.`);
                     return;
                 } else {
                     // Other error moving placeholder
                     handleStorageError(movePlaceholderError, `renameFolder - move placeholder`);
                 }
             } catch (placeholderError) {
                  console.error(`Error trying to move placeholder for ${oldPrefix}:`, placeholderError);
             }
            return;
        }

        console.log(`Found ${itemsToMove.length} items to move/rename.`);

        // 2. Create the new parent folder structure (optional, move might create it)
        // It's safer to ensure the parent directory for the new prefix exists if it's nested
        const newParentPath = newPrefix.includes('/') ? newPrefix.substring(0, newPrefix.lastIndexOf('/')) : '';
        if (newParentPath) {
            // Attempt to create folder - will ignore if exists
            await createFolder(bucket, newParentPath);
        }


        // 3. Move each item
        // Sort to move parent folders first? Supabase move might handle this.
        // Let's move files first, then attempt folder moves (or rely on implicit folder creation)
        const filesToMove = itemsToMove.filter(item => item.type === 'file');
        const foldersToMove = itemsToMove.filter(item => item.type === 'folder');

        // Move files
        for (const file of filesToMove) {
            const oldPath = file.path;
            const newPath = oldPath.replace(oldPrefix, newPrefix); // Replace prefix
            console.log(`Moving file: ${oldPath} -> ${newPath}`);
            await moveFile(bucket, oldPath, newPath);
        }

        // Optionally, attempt to move folder placeholders if they exist
        // Supabase `move` might implicitly handle folder structure, but explicit moves can be safer
        // Or, rely on the fact that moving files might recreate the structure.
        // Let's try moving the original folder placeholder if it exists.
         try {
             const { error: moveMainPlaceholderError } = await supabase.storage
                 .from(bucket)
                 .move(`${oldPrefix}/.placeholder`, `${newPrefix}/.placeholder`);
             if (moveMainPlaceholderError && !moveMainPlaceholderError.message.includes('does not exist')) {
                  handleStorageError(moveMainPlaceholderError, `renameFolder - move main placeholder`);
             } else if (!moveMainPlaceholderError) {
                 console.log(`Moved main placeholder for ${oldPrefix}`);
             }
         } catch(e) { console.warn("Could not move main placeholder, might not exist."); }


        // 4. Delete the old folder structure (optional, might be empty now)
        // Be cautious with recursive deletion. Ensure all items were moved successfully first.
        // It might be safer to leave this step manual or implement careful checks.
        console.warn(`Rename operation moved files. Manual cleanup of the old folder structure '${oldPrefix}' might be needed if Supabase move didn't handle it implicitly.`);
        // Example cleanup (use with caution):
        // try {
        //     await deleteFolder(bucket, oldPrefix); // Requires a robust deleteFolder implementation
        //     console.log(`Attempted cleanup of old folder: ${oldPrefix}`);
        // } catch (cleanupError) {
        //     console.error(`Error during cleanup of old folder ${oldPrefix}:`, cleanupError);
        // }


        console.log(`Successfully completed rename operation for folder: ${oldPrefix} -> ${newPrefix}`);

    } catch (error: unknown) {
        console.error(`Caught error in renameFolder (Bucket: ${bucket}, From: ${oldPrefix}, To: ${newPrefix}):`, error instanceof Error ? error.message : error);
        throw error;
    }
};


// Deletes a folder and all its contents recursively
// NOTE: Use with extreme caution!
// TODO: Review if this needs changes (likely not)
export const deleteFolder = async (bucket: string, folderPathPrefix: string): Promise<void> => {
     console.warn(`Attempting to recursively delete folder and all its contents: Bucket=${bucket}, PathPrefix=${folderPathPrefix}`);
     if (!folderPathPrefix) {
         throw new Error("Folder path prefix cannot be empty for deleteFolder.");
     }
     // Ensure prefix doesn't have leading/trailing slashes for consistency
     const prefix = folderPathPrefix.replace(/^\/|\/$/g, '');
      if (!prefix) {
         throw new Error("Cannot delete the root directory.");
     }

     try {
         // 1. List all files under the prefix
         console.log(`Listing files to delete under prefix: ${prefix}`);
         // Need to list recursively - use getAllStorageItems or similar logic
         const allItems = await getAllStorageItems(bucket); // Get all items
         const itemsToDelete = allItems.filter(item => item.path.startsWith(prefix + '/') || item.path === prefix);
         const filesToDelete = itemsToDelete.filter(item => item.type === 'file').map(item => item.path);

         if (filesToDelete.length > 0) {
             console.log(`Found ${filesToDelete.length} files to delete.`);
             // 2. Delete all found files
             const { data: deletedFilesData, error: deleteFilesError } = await supabase.storage
                 .from(bucket)
                 .remove(filesToDelete);

             handleStorageError(deleteFilesError, `deleteFolder - remove files (Bucket: ${bucket}, Prefix: ${prefix})`);
             console.log(`Successfully deleted ${deletedFilesData?.length || 0} files under prefix: ${prefix}`);
         } else {
             console.log(`No files found under prefix ${prefix} to delete.`);
         }

         // 3. Optionally delete placeholder files if they exist (might represent empty folders)
         // This part is tricky as Supabase doesn't explicitly list empty folders via .list() easily.
         // Deleting the files *should* allow Supabase to clean up empty parent structures,
         // but explicit deletion of placeholders might be needed in some cases.
         // We'll rely on file deletion for now. Add placeholder deletion if needed.
         // Example: await deleteFile(bucket, `${prefix}/.placeholder`);

         console.log(`Completed delete operation for folder prefix: ${prefix}. Note: Empty folder structures might persist if not automatically cleaned by Supabase.`);

     } catch (error: unknown) {
         console.error(`Caught error in deleteFolder (Bucket: ${bucket}, Prefix: ${prefix}):`, error instanceof Error ? error.message : error);
         throw error;
     }
 };
